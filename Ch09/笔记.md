0. 元素在顺序容器中的顺序与其加入容器时的位置相对应。标准库还定义了几种关联容器，关联容器中元素的位置由元素相关联的关键字决定。  
所有容器类都共享公共的接口，不同容器按不同的方式对其进行扩展

1. 一个容器就是一些特定类型对象的集合。
    * 顺序容器为程序员提供了控制元素存储和访问顺序的能力。  
2. 所有顺序容器都提供了快速顺序访问元素的能力。但是存在以下的性能折中：
    * 向容器添加或者从容器中删除元素的代价  
    * 非顺序访问容器中元素的代价  
3. 顺序容器类型
    * vector  可变大小数组
    * deque  双端队列
    * list  双向链表
    * forward_list  单向链表
    * array  固定大小数组
    * string  与vector相似的容器

    除了固定大小的array外，其他容器都提供高效、灵活的内存管理。可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。 

>string和vector将元素保存在连续的内存空间中，元素的下标计算其地址是非常快速的，但是在中间添加和删除元素就会非常耗时
list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。
deque支持快速的随机访问，与string和vector一样，在deque的中间位置添加或者删除元素的代价很高；但是在deque的两端添加或删除元素是很快的。
forword_list和array是新C++标准增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。
array对象的大小是固定的，不支持添加和删除元素以及改变容器大小的操作。
新标准库的容器比旧版本快的多。  

4. 确定使用哪种顺序容器  
通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。  

选择容器的基本原则
* 除非你有很好的理由选择其他容器，否则应使用vector
* 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list  
* 如果程序要求随机访问元素，应使用vector或deque  
* 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list
* 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或者删除操作，则使用deque  
* 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
    * 首先 ，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，再调用标准库的sort函数
    * 如果在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中


## 容器库概览
一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义在头文件deque中，list定义在头文件list中，以此类推。

>容器均定义为模板类

list<Sales_data> //保存Sales_data对象的list
deque<double> //保存double的deque

### 对容器可以保存的元素类型的限制
顺序容器几乎可以保存任意类型的元素，特别是，我们可以定义一个容器，其元素的类型是另一个容器。

vector<vector<string>> lines; //vector的vector

此处lines是一个vector，其元素类型是string的vector

>较旧的编译器可能需要在两个尖括号之间键入空格。vector<vector<string> >  

顺序容器构造函数的一个版本接受容器大小参数，使用了元素类型的默认构造函数。但某些类没有默认构造函数，可以定义一个保存这种类型对象的容器。

//假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); //正确：提供了元素初始化器
vector<noDefault> v2(10);  //错误：必须提供一个元素初始化器

### 迭代器
与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。  
标准容器的所有迭代器都定义了递增运算符，从当前元素移动到下一个元素。  

**迭代器范围**
一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。两个迭代器通常被称为begin和end或者是first和last，标记了容器中元素的一个范围。    

第二个迭代器从来不会指向范围中的最后一个元素，而是指向尾元素之后的位置。迭代器范围中的元素包含first所表示的元素以及从first开始直至last之间的所有元素。这种元素范围被称为左闭合区间，标准数学描述[begin,end)

>对构成范围的迭代器的要求
如果满足如下条件，两个迭代器begin和end构成一个迭代器范围
* 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且
* 可以通过反复递增begin来到达end。换句话说，end不在begin之前。  

标准库使用左闭合范围是因为这种范围有三种方便的性质。假定begin和end构成一个合法的迭代器范围，则
* 如果begin与end相等，则范围为空  
* 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素
* 我们可以对begin递增若干次，使用begin==end

### 容器类型成员
除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。简单的说，反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义发生了颠倒。例如，对一个反向迭代器执行++操作，会得到上一个元素。

为了使用这些类型，必须显示使用其类名
//iter 是通过list<string> 定义的一个迭代器类型
list<string>::iterator iter;
//count 是通过vector<int>定义的一个different_type类型

vector<int>::different_type count;

