# 泛型算法  

顺序容器只定义了很少的操作:（1）添加和删除元素 （2）访问首尾元素 （3）确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。  

TODO操作: （1）查找特定元素 （2） 替换或删除一个特定值 （3）重排元素顺序  

泛型算法实现了一些经典算法的公共接口，如排序和搜索，并且可以用于不同类型的元素和多种容器类型（不仅包含标准库类型，vector或者list, 还包括内置的数组类型）

## 概述

算法定义的头文件 algorithm; 标准库还在头文件numeric中定义了一组数值泛型算法   

定义的算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围进行操作。

例如，有一个int的vector，希望vector中是否包含一个特定值，调用标准库算法find.

```
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val)
cout << "the value " << val 
     << (result == vec.cend()?"is not present.":"is present") << endl; 

```

传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。 find将范围中的每个元素与给定值进行比较。返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败。

内置数组的迭代器 

```
int ia[] = {12,45,7,89,34};
begin(ia),end(ia)
```

还可以在序列的子范围查找，只需将子范围首元素和尾元素之后位置的迭代器传递即可。
```
auto result = find(ia+1, ia+4, val);
```

## 初始泛型算法

## 定制操作

## 再探迭代器  

## 泛型算法结构  

## 特定容器算法  

